buildscript {
    repositories {
        maven { url = 'https://files.minecraftforge.net/maven' }
        maven { url = 'http://repo.spongepowered.org/maven' }
        jcenter()
        mavenCentral()
        gradlePluginPortal()
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '3.+', changing: true
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
        classpath 'org.spongepowered:mixingradle:0.7-SNAPSHOT'
        // rolled back from 4.0.4 to 4.0.1 due to #425: https://github.com/johnrengelman/shadow/issues/425
        classpath 'com.github.jengelman.gradle.plugins:shadow:4.0.1'
        // for some reason, unless I add these here, `tasks.withType(KotlinCompile)` doesn't detect the compileKotlin
        // task. Maybe these mess with the classpath, leading to the build.gradle (which applies the kotlin plugin) and
        // this file using different copies of `KotlinCompile`?
        classpath "org.jfrog.buildinfo:build-info-extractor-gradle:latest.release"
        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.+'
    }
}

apply plugin: 'kotlin'
apply plugin: 'net.minecraftforge.gradle'
apply plugin: 'org.spongepowered.mixin'
apply plugin: 'com.github.johnrengelman.shadow'

import com.github.jengelman.gradle.plugins.shadow.ShadowStats
import com.github.jengelman.gradle.plugins.shadow.relocation.RelocatePathContext
import com.github.jengelman.gradle.plugins.shadow.relocation.Relocator
import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar

ext.modid = project.name == "core" ? "librarianlib" : "librarianlib-${project.name}".toString()
ext.modid_test = "$modid-test".toString()

// Need this here so eclipse task generates correctly.
sourceCompatibility = targetCompatibility = compileJava.sourceCompatibility = compileJava.targetCompatibility = '1.8'
archivesBaseName = modid

ext.shadeRules = new HashSet<String>()
ext.shadePackages = { String... packages ->
    shadeRules.addAll(packages)
}
allmodules.each {
    if(file("$it.projectDir/prebuild.gradle").exists()) {
        apply from: "$it.projectDir/prebuild.gradle"
    }
}

configurations {
    compileOnly.extendsFrom(shade)
    testCompileOnly.extendsFrom(shade)
    // `internalApi` is automatically added to all project dependencies, allowing us to easily expose
    // some libraries as APIs internally without them appearing in the maven POM files.
    internalApi.extendsFrom(shade)
    api.extendsFrom(mod)
    testApi.extendsFrom(mod)
    devClasspath // included in the run configuration classpath
}

minecraft {
    mappings channel: mc_mappings_channel, version: mc_mappings_version
}

dependencies {
    minecraft "net.minecraftforge:forge:$mc_version-$forge_version"
    annotationProcessor "org.spongepowered:mixin:$mixin_version:processor"
    testAnnotationProcessor "org.spongepowered:mixin:$mixin_version:processor"
    api "org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlin_version"
    api "org.jetbrains.kotlin:kotlin-reflect:$kotlin_version"
    api "org.jetbrains.kotlinx:kotlinx-coroutines-jdk8:$kotlin_coroutines_version"
    api "org.jetbrains:annotations:$jetbrains_annotations_version"
    api rootProject.files('libs/Kottle-2.0.0-slim.jar')
//    api "kottle:Kottle:$kottle_version:slim"
}

// go through each configuration and add an `internalApi` dependency alongside each project dependency
afterEvaluate {
    dependencies {
        configurations.api.dependencies.findAll { it instanceof ProjectDependency }.collect { ProjectDependency dep ->
            internalApi project(path: dep.getDependencyProject().path, configuration: "internalApi")
            compileOnly project(path: dep.getDependencyProject().path, configuration: "internalApi")
        }
        configurations.testApi.dependencies.findAll { it instanceof ProjectDependency }.collect { ProjectDependency dep ->
            testCompileOnly project(path: dep.getDependencyProject().path, configuration: "internalApi")
        }
    }
}

kotlin {
    explicitApi = 'warning'
}

tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
    kotlinOptions {
        jvmTarget = "1.8"
        freeCompilerArgs += [
                "-java-parameters",
                "-Xjvm-default=all",
                "-Xuse-experimental=kotlin.Experimental",
                "-Xuse-experimental=kotlin.ExperimentalUnsignedTypes"
        ]
    }
}

// exclude "master" files from output
def masterPatterns = [
        "**/*.psd",
        "**/*.xcf",
        "**/*.kra",
        "**/*.blend",
        "**/_master/**"
]

processResources {
    masterPatterns.each {
        exclude it
    }
}
processTestResources {
    masterPatterns.each {
        exclude it
    }
}

// =====================================================================================================================
//region // Build setup

sourceSets {
    main {
        ext.refMap = "ll-${project.name}.refmap.json"
        resources.srcDir("src/main/datagen")
    }
    test {
        ext.refMap = "ll-${project.name}-test.refmap.json"
        resources.srcDir("src/test/datagen")
    }
}

// ---------------------------------------------------------------------------------------------------------------------
//region // File generation
apply from: "$rootDir/gradle/generatorUtils.gradle"

static String tomlDependency(String modid, String dependencyid, String version, String ordering) {
    return """\
       |[[dependencies.$modid]]
       |    modId="$dependencyid"
       |    versionRange="$version"
       |    mandatory=true
       |    ordering="$ordering"
       |""".stripMargin()
}

// Generated files:
// - MixinConnector.java
//   - generated by merging all the `META-INF/mixins.txt` files
// - SkeletonMod.java
//   - generated based on the mod ID
// - META-INF/mods.toml
//   - generated by appending the `META-INF/dependencies.toml` files to a skeleton `mods.toml` file
// - pack.mcmeta
task generateFiles {
    description 'Automatically generates boilerplate files'

    inputs.properties mod_version: mod_version, human_name: human_name, modid: modid, description: description

    ext.genJava = "$buildDir/generated/main/java"
    ext.genResources = "$buildDir/generated/main/resources"
    ext.resourcesDir = "$projectDir/src/main/resources"

    ext.mixinFiles = fileTree(dir: "$resourcesDir/META-INF/ll/$project.name/mixins", includes: ['*.json'])
    ext.coremodFiles = fileTree(dir: "$resourcesDir/META-INF/ll/$project.name/asm", includes: ['*.js'])
    ext.manifest = file("$resourcesDir/META-INF/MANIFEST.MF")

    inputs.files(
            mixinFiles,
            coremodFiles,
            manifest
    )

    ext.mixinConnectorOut = file("$genJava/gen/${project.name}/MixinConnector.java")
    ext.coremodsOut = file("$genResources/META-INF/coremods.json")
    ext.manifestOut = file("$genResources/META-INF/MANIFEST.MF")
    outputs.files(
            mixinConnectorOut,
            coremodsOut,
            manifestOut
    )
    ext.skeletonModOut = file("$genJava/gen/${project.name}/SkeletonMod.java")
    ext.modsTomlOut = file("$genResources/META-INF/mods.toml")
    ext.packMcmetaOut = file("$genResources/pack.mcmeta")
    if(project.name != "core")
        outputs.files(
                skeletonModOut,
                modsTomlOut,
                packMcmetaOut
        )

    doLast {
        modsTomlOut.parentFile.mkdirs()

        mixinConnectorOut.text = GeneratorUtils.generateMixinConnector("gen.$project.name", "MixinConnector", mixinFiles)
        coremodsOut.text = GeneratorUtils.generateCoremodsJson(coremodFiles)

        manifestOut.text = (manifest.exists() ? manifest.text : "") + "MixinConnector: gen.${project.name}.MixinConnector\n"

        if(project.name != "core") {
            skeletonModOut.text = """\
               |package gen.${project.name};
               |
               |import net.minecraftforge.fml.common.Mod;
               |
               |@Mod("$modid")
               |public class SkeletonMod {}
            |""".stripMargin()

            def tomlString = """\
                   |modLoader="kotlinfml"
                   |loaderVersion="[1,)"
                   |[[mods]]
                   |modId="$modid"
                   |version="$mod_version"
                   |displayName="LibrarianLib $human_name"
                   |description="$description"
                   |[[dependencies.$modid]]
                   |    modId="librarianlib"
                   |    versionRange="[$mod_version]"
                   |    mandatory=true
                   |    ordering="AFTER"
            |""".stripMargin() // ordering after so by depending on liblib, all the modules will load before it too.
            modsTomlOut.text = tomlString

            packMcmetaOut.text = """\
                   |{
                   |    "pack": {
                   |        "description": "LibrarianLib $human_name resources",
                   |        "pack_format": 4
                   |    }
                   |}
                |""".stripMargin()
        }
    }
}
sourceSets.main.java.srcDirs(generateFiles.genJava)
sourceSets.main.resources.srcDirs(generateFiles.genResources)
compileJava.dependsOn(generateFiles)
compileKotlin.dependsOn(generateFiles)

// Generated test files:
// - MixinConnector.java
//   - generated by merging all the `META-INF/mixins.txt` files
// - SkeletonMod.java
//   - generated based on the mod ID
// - META-INF/mods.toml
//   - generated by appending the `META-INF/dependencies.toml` files to a skeleton `mods.toml` file
// - pack.mcmeta
task generateTestFiles {
    description 'Automatically generates boilerplate files'

    inputs.properties mod_version: mod_version, human_name: human_name, modid_test: modid_test

    ext.genJava = "$buildDir/generated/test/java"
    ext.genResources = "$buildDir/generated/test/resources"
    ext.resourcesDir = "$projectDir/src/test/resources"

    ext.mixinFiles = fileTree(dir: "$resourcesDir/META-INF/ll/$project.name/mixin", includes: ['*.mixin.json'])
    ext.coremodFiles = fileTree(dir: "$resourcesDir/META-INF/ll/$project.name/asm", includes: ['*.js'])
    ext.dependenciesToml = file("$resourcesDir/META-INF/dependencies.toml")
    ext.manifest = file("$resourcesDir/META-INF/MANIFEST.MF")

    inputs.files(
            mixinFiles,
            coremodFiles,
            dependenciesToml,
            manifest
    )

    ext.mixinConnectorOut = file("$genJava/gen/${project.name}/TestMixinConnector.java")
    ext.modsTomlOut = file("$genResources/META-INF/mods.toml")
    ext.coremodsOut = file("$genResources/META-INF/coremods.json")
    ext.manifestOut = file("$genResources/META-INF/MANIFEST.MF")
    ext.packMcmetaOut = file("$genResources/pack.mcmeta")
    outputs.files(
            mixinConnectorOut,
            modsTomlOut,
            coremodsOut,
            manifestOut,
            packMcmetaOut
    )

    doLast {
        modsTomlOut.parentFile.mkdirs()

        mixinConnectorOut.text = GeneratorUtils.generateMixinConnector("gen.$project.name", "TestMixinConnector", mixinFiles)
        coremodsOut.text = GeneratorUtils.generateCoremodsJson(coremodFiles)

        manifestOut.text = (manifest.exists() ? manifest.text : "") + "MixinConnector: gen.${project.name}.TestMixinConnector\n"

        packMcmetaOut.text = """\
               |{
               |    "pack": {
               |        "description": "LibrarianLib $human_name resources",
               |        "pack_format": 4
               |    }
               |}
            |""".stripMargin()

        def tomlString = """\
               |modLoader="kotlinfml"
               |loaderVersion="[1,)"
               |[[mods]]
               |modId="$modid_test"
               |version="$mod_version"
               |displayName="LibrarianLib $human_name Test"
               |description="Tests for the $human_name module"
        |""".stripMargin()
        tomlString += """\
               |[[dependencies.$modid_test]]
               |    modId="librarianlib"
               |    versionRange="[$mod_version]"
               |    mandatory=true
               |    ordering="BEFORE"
        |""".stripMargin()
        if(dependenciesToml.exists())
            tomlString += dependenciesToml.text.replaceAll("\\s+\$", "")
        modsTomlOut.text = tomlString
    }
}
sourceSets.test.java.srcDirs(generateTestFiles.genJava)
sourceSets.test.resources.srcDirs(generateTestFiles.genResources)
compileTestJava.dependsOn(generateTestFiles)
compileTestKotlin.dependsOn(generateTestFiles)

//endregion
// ---------------------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------------------
//region // Shading

def shadeOutput = file("$buildDir/shade/main")
// Gross, but ForgeGradle forces my hand by directly using `getResourcesDir()` and `getClassesDirs()` instead of
// using `getOutput()`, meaning I can't just do `output.dir(shadeOutput, builtBy: 'copyShadeClasses')`. I could
// use a separate sourceSet, however that comes with the baggage of a bunch of tasks, configurations, and source
// directories (which an IDE may conveniently create for you automatically)
// https://github.com/MinecraftForge/ForgeGradle/blob/ccf3035ba1f435f0f1a685a70d85df5481ee8b73/src/common/java/net/minecraftforge/gradle/common/util/runs/RunConfigGenerator.java#L128
// https://github.com/MinecraftForge/ForgeGradle/blob/ccf3035ba1f435f0f1a685a70d85df5481ee8b73/src/common/java/net/minecraftforge/gradle/common/util/runs/RunConfigGenerator.java#L138
((ConfigurableFileCollection)sourceSets.main.output.classesDirs).from(shadeOutput)

afterEvaluate {
    task copyShadeClasses(type: Sync) {
        into shadeOutput
        from configurations.shade.collect { zipTree(it) }
        exclude 'META-INF', 'META-INF/**'
    }
    compileJava.finalizedBy(copyShadeClasses)
}
//endregion
// ---------------------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------------------
//region // Jars

def attributes = [
        "Implementation-Title": "LibrarianLib $human_name",
        "Implementation-Version": "$mod_version",
        "Implementation-Vendor": "Team Wizardry",
        "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
        // Specify the IMixinConnector. This contains only the mixin files from this specific module.
        // https://github.com/SpongePowered/Mixin/wiki/Release-Notes---Mixin-0.8#toolchain-and-environment-changes
        "MixinConnector": "gen.${project.name}.MixinConnector"
]

task sourcesJar(type: Jar) {
    classifier = 'sources'
    includeEmptyDirs = false
    manifest.attributes(attributes)
    from sourceSets.main.allSource
    from sourceSets.main.output.resourcesDir
    dependsOn processResources
    exclude '**/*.class'
}

task deobfJar(type: ShadowJar) {
    configurations = []
    classifier = ''
    includeEmptyDirs = false
    manifest.attributes(attributes)

    from sourceSets.main.output
    dependsOn classes
    dependsOn processResources

    afterEvaluate {
        // add relocation rules after all the projects have added their packages to the list
        project.shadeRules.each {
            relocate it, "ll.$it"
        }
    }
}

task obfJar(type: Jar) {
    dependsOn deobfJar
    classifier = 'obf'
    manifest.attributes(attributes)
    from zipTree(deobfJar.archivePath)
}

jar {
    enabled = false
}

reobf {
    obfJar
}

assemble.dependsOn obfJar, deobfJar, sourcesJar

// create a sources jar that includes this module and the shaded dependencies
// Based largely on the gradle-preshadow-plugin: https://github.com/Abnaxos/gradle-preshadow-plugin/blob/07580f93f38818b15c411f6c47abea8cdfd0b2f9/src/main/groovy/ch/raffael/gradlePlugins/preshadow/Preshadow.groovy
// has to be run in afterEvaluate since the relocator package list isn't ready until all the modules are configured
afterEvaluate {
    sourcesJar {
        // collect the sources for all the shade dependencies
        from configurations.detachedConfiguration(
                configurations.shade.allDependencies.collect({ dep ->
                    def sourceDep = dependencies.create(group: dep.group,
                            name: dep.name,
                            classifier: 'sources',
                            version: dep.version)
                    // apply any exclusions from the main dependency to the sources dependency
                    if (dep instanceof ModuleDependency && sourceDep instanceof ModuleDependency) {
                        def originalModule = (ModuleDependency) dep
                        def sourceModule = (ModuleDependency) sourceDep

                        originalModule.excludeRules.each {
                            sourceModule.exclude group: it.group, module: it.module
                        }
                    }
                    return sourceDep
                }) as Dependency[]).collect { f ->
            f.directory ? fileTree(f) : zipTree(f)
        }
        def stats = new ShadowStats()
        // remap sources
        eachFile { FileCopyDetails copyDetails ->
            deobfJar.relocators.each { Relocator reloc ->
                def pathContext = new RelocatePathContext(copyDetails.sourcePath, stats)
                if (reloc.canRelocatePath(pathContext)) {
                    copyDetails.path = reloc.relocatePath(pathContext)
                }
                if (!copyDetails.directory)
                    copyDetails.filter { String line ->
                        reloc.applyToSourceContent(line)
                    }
            }
        }
    }
}

//endregion
// ---------------------------------------------------------------------------------------------------------------------

//endregion
// =====================================================================================================================
